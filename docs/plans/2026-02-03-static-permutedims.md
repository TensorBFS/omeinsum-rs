# Static Permutedims Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Generate Julia-like specialized nested loop permutation functions for ranks 1-40 at build time, eliminating runtime coordinate array allocation and branching overhead.

**Architecture:** Use `build.rs` to generate `permute_generated.rs` containing 40 specialized `permute_static_N` functions. Each function uses N nested loops with incremental source index updates (like Julia's `@nloops`). A dispatch function routes based on runtime rank.

**Tech Stack:** Rust build script (`build.rs`), no external dependencies.

---

## Background

Julia's `permutedims!` uses `@generated` functions with `@nloops` to create specialized nested loops:
```julia
@nloops N i P begin
    P[ind] = B[sumc+offset]
    ind += 1
end
```

This avoids:
- Heap-allocated coordinate arrays
- Runtime branching for carry logic
- Dynamic dispatch overhead

We replicate this in Rust using build-time code generation.

---

### Task 1: Clean Up Existing Manual Implementation

**Files:**
- Delete: `src/backend/cpu/permute_static.rs`
- Modify: `src/backend/cpu/mod.rs`

**Step 1: Remove the manual permute_static.rs module**

Delete the file `src/backend/cpu/permute_static.rs` (it contains manually written ranks 1-6).

**Step 2: Remove module declaration from mod.rs**

In `src/backend/cpu/mod.rs`, remove the line:
```rust
mod permute_static;
```

**Step 3: Verify build still works**

Run: `cargo build --release 2>&1 | tail -5`
Expected: Build succeeds (with warnings about unused permute_2d)

**Step 4: Commit**

```bash
git add -u
git commit -m "refactor(cpu): remove manual permute_static in prep for codegen"
```

---

### Task 2: Create Build Script Code Generator

**Files:**
- Modify: `build.rs`

**Step 1: Add permute codegen function to build.rs**

Add this code to `build.rs` before `fn main()`:

```rust
use std::io::Write;

/// Generate static permutation functions for ranks 1..=max_rank
fn generate_permute_static(max_rank: usize) -> String {
    let mut code = String::new();

    // File header
    code.push_str("//! Auto-generated static permutation functions.\n");
    code.push_str("//! Generated by build.rs - DO NOT EDIT.\n");
    code.push_str("//!\n");
    code.push_str("//! Each function uses nested loops with incremental index updates,\n");
    code.push_str("//! similar to Julia's @nloops approach.\n\n");

    // Generate function for each rank
    for rank in 1..=max_rank {
        code.push_str(&generate_permute_fn(rank));
        code.push('\n');
    }

    // Generate dispatch function
    code.push_str(&generate_dispatch_fn(max_rank));

    code
}

/// Generate a single permute_static_N function
fn generate_permute_fn(rank: usize) -> String {
    let mut code = String::new();

    code.push_str(&format!(
        r#"/// Static permutation for rank-{rank} tensors.
#[inline]
pub fn permute_static_{rank}<T: Copy>(
    dst: &mut [T],
    src: &[T],
    shape: &[usize; {rank}],
    steps: &[usize; {rank}],
) {{
    unsafe {{
        let src_ptr = src.as_ptr();
        let dst_ptr = dst.as_mut_ptr();
        let mut dst_idx = 0usize;
"#,
        rank = rank
    ));

    // Generate nested loops
    // Outermost loop is for dimension rank-1, innermost is dimension 0
    for d in (0..rank).rev() {
        let indent = "        ".to_string() + &"    ".repeat(rank - 1 - d);
        if d == rank - 1 {
            code.push_str(&format!("{indent}let mut src_{d} = 0usize;\n"));
        }
        code.push_str(&format!("{indent}for _ in 0..shape[{d}] {{\n"));
        if d > 0 {
            code.push_str(&format!("{indent}    let mut src_{} = src_{d};\n", d - 1));
        }
    }

    // Innermost body: copy element and increment
    let inner_indent = "        ".to_string() + &"    ".repeat(rank);
    code.push_str(&format!("{inner_indent}*dst_ptr.add(dst_idx) = *src_ptr.add(src_0);\n"));
    code.push_str(&format!("{inner_indent}dst_idx += 1;\n"));
    code.push_str(&format!("{inner_indent}src_0 = src_0.wrapping_add(steps[0]);\n"));

    // Close loops with stride updates
    for d in 0..rank {
        let indent = "        ".to_string() + &"    ".repeat(d);
        code.push_str(&format!("{indent}    }}\n"));
        if d < rank - 1 {
            code.push_str(&format!("{indent}    src_{} = src_{}.wrapping_add(steps[{}]);\n", d, d + 1, d + 1));
        }
    }

    code.push_str("    }\n");
    code.push_str("}\n");

    code
}

/// Generate the dispatch function
fn generate_dispatch_fn(max_rank: usize) -> String {
    let mut code = String::new();

    code.push_str(&format!(
        r#"/// Dispatch to static permutation based on runtime rank.
/// Returns true if handled, false if rank > {max_rank} (fallback needed).
#[inline]
pub fn permute_static_dispatch<T: Copy + Default>(
    dst: &mut [T],
    src: &[T],
    shape: &[usize],
    steps: &[usize],
) -> bool {{
    match shape.len() {{
"#,
        max_rank = max_rank
    ));

    for rank in 1..=max_rank {
        code.push_str(&format!(
            r#"        {rank} => {{
            let shape: &[usize; {rank}] = shape.try_into().unwrap();
            let steps: &[usize; {rank}] = steps.try_into().unwrap();
            permute_static_{rank}(dst, src, shape, steps);
            true
        }}
"#,
            rank = rank
        ));
    }

    code.push_str("        _ => false,\n");
    code.push_str("    }\n");
    code.push_str("}\n");

    code
}
```

**Step 2: Add codegen call to main()**

At the beginning of `fn main()` in `build.rs`, add:

```rust
    // Generate static permutation functions
    let out_dir = std::env::var("OUT_DIR").unwrap();
    let permute_path = std::path::Path::new(&out_dir).join("permute_generated.rs");
    let mut file = std::fs::File::create(&permute_path).unwrap();
    file.write_all(generate_permute_static(40).as_bytes()).unwrap();
    println!("cargo:rerun-if-changed=build.rs");
```

**Step 3: Verify build script runs**

Run: `cargo build --release 2>&1 | grep -E "(Compiling|warning:.*permute)"`
Expected: Compiles without errors

**Step 4: Verify generated file exists**

Run: `ls -la target/release/build/omeinsum-*/out/permute_generated.rs 2>/dev/null | head -1`
Expected: File exists

**Step 5: Commit**

```bash
git add build.rs
git commit -m "build: add codegen for static permutation ranks 1-40"
```

---

### Task 3: Include Generated Code in Module

**Files:**
- Modify: `src/backend/cpu/mod.rs`

**Step 1: Add module that includes generated code**

In `src/backend/cpu/mod.rs`, after `mod contract;`, add:

```rust
/// Auto-generated static permutation functions (ranks 1-40).
pub mod permute_generated {
    include!(concat!(env!("OUT_DIR"), "/permute_generated.rs"));
}
```

**Step 2: Verify build succeeds**

Run: `cargo build --release 2>&1 | tail -5`
Expected: Build succeeds

**Step 3: Commit**

```bash
git add src/backend/cpu/mod.rs
git commit -m "feat(cpu): include generated permute functions"
```

---

### Task 4: Integrate Static Dispatch into permute_impl

**Files:**
- Modify: `src/backend/cpu/contract.rs`

**Step 1: Update permute_impl to use static dispatch**

In `src/backend/cpu/contract.rs`, find the `permute_impl` function and replace it with:

```rust
/// Core permutation implementation with specializations.
#[inline(never)]
fn permute_impl<T: Copy + Default + Send + Sync>(
    data: &[T],
    new_shape: &[usize],
    steps: &[usize],
    numel: usize,
) -> Vec<T> {
    // Allocate result
    let mut result = vec![T::default(); numel];

    // Try static dispatch (ranks 1-40)
    if super::permute_generated::permute_static_dispatch(&mut result, data, new_shape, steps) {
        return result;
    }

    // Fallback for rank > 40 (very rare)
    permute_nd(&mut result, data, new_shape, steps);
    result
}
```

**Step 2: Remove now-unused functions**

Remove these functions from `contract.rs` as they're replaced by codegen:
- `permute_1d`
- `permute_2d`

**Step 3: Verify build succeeds**

Run: `cargo build --release 2>&1 | tail -5`
Expected: Build succeeds (possibly with warnings about unused code)

**Step 4: Commit**

```bash
git add src/backend/cpu/contract.rs
git commit -m "feat(cpu): use generated static permute for ranks 1-40"
```

---

### Task 5: Run Benchmark to Verify Performance

**Files:**
- None (benchmark only)

**Step 1: Build benchmark**

Run: `cd /home/leo/jcode/TensorNetworkBenchmarks/rust && cargo build --release`
Expected: Build succeeds

**Step 2: Run benchmark (without parallel)**

Run: `./target/release/benchmark --repeat-times 3`
Expected: Performance similar or better than before (~28s or less)

**Step 3: Record results**

Note the min/avg time for comparison with Julia (16.4s target).

**Step 4: Commit any final fixes**

If needed, commit any adjustments.

---

### Task 6: Add Unit Tests for Generated Functions

**Files:**
- Create: `src/backend/cpu/permute_tests.rs`
- Modify: `src/backend/cpu/mod.rs`

**Step 1: Create test module**

Create `src/backend/cpu/permute_tests.rs`:

```rust
//! Tests for generated static permutation functions.

#[cfg(test)]
mod tests {
    use crate::backend::cpu::permute_generated::*;

    #[test]
    fn test_permute_static_1_identity() {
        let src = [1, 2, 3, 4, 5];
        let mut dst = [0; 5];
        permute_static_1(&mut dst, &src, &[5], &[1]);
        assert_eq!(dst, [1, 2, 3, 4, 5]);
    }

    #[test]
    fn test_permute_static_1_strided() {
        let src = [1, 2, 3, 4, 5, 6];
        let mut dst = [0; 3];
        permute_static_1(&mut dst, &src, &[3], &[2]);
        assert_eq!(dst, [1, 3, 5]);
    }

    #[test]
    fn test_permute_static_2_transpose() {
        // 2x3 column-major: [0,1,2,3,4,5] represents:
        // [[0,2,4], [1,3,5]]
        // Transpose to 3x2: [[0,1], [2,3], [4,5]] = [0,2,4,1,3,5]
        let src = [0, 1, 2, 3, 4, 5];
        let mut dst = [0; 6];
        // new_shape = [3, 2], steps = [2, 1]
        permute_static_2(&mut dst, &src, &[3, 2], &[2, 1]);
        assert_eq!(dst, [0, 2, 4, 1, 3, 5]);
    }

    #[test]
    fn test_permute_static_3_identity() {
        let src: Vec<i32> = (0..8).collect();
        let mut dst = vec![0; 8];
        // 2x2x2 with identity strides
        permute_static_3(&mut dst, &src, &[2, 2, 2], &[1, 2, 4]);
        assert_eq!(dst, src);
    }

    #[test]
    fn test_permute_static_dispatch() {
        let src = [1, 2, 3, 4];
        let mut dst = [0; 4];

        // Should handle rank 2
        assert!(permute_static_dispatch(&mut dst, &src, &[2, 2], &[1, 2]));
        assert_eq!(dst, [1, 2, 3, 4]);
    }
}
```

**Step 2: Add test module to mod.rs**

In `src/backend/cpu/mod.rs`, add:

```rust
#[cfg(test)]
mod permute_tests;
```

**Step 3: Run tests**

Run: `cargo test --release permute_tests`
Expected: All tests pass

**Step 4: Commit**

```bash
git add src/backend/cpu/permute_tests.rs src/backend/cpu/mod.rs
git commit -m "test(cpu): add unit tests for generated permute functions"
```

---

## Verification

After all tasks complete:

1. **Correctness**: `cargo test --release` passes
2. **Performance**: Benchmark shows improvement over dynamic version
3. **Code size**: Check binary size increase is acceptable (~100KB for 40 functions)

Run: `ls -lh target/release/libomeinsum.rlib`

---

## Notes

- The generated code uses `wrapping_add` to handle potential overflow safely
- Ranks > 40 fall back to the dynamic `permute_nd` implementation
- The 40-rank limit covers virtually all practical tensor network contractions
